<!DOCTYPE html>
<html>
<head></head>
<body>
	
  <h1 style='text-align: center; margin-bottom: -35px;'>Model deployment: Tensorflow.js hand-written letter and number classification webapp</h1>
  <br><br>
	
<h2 id="select_model" style='text-align: left; display:block'>Write captial letters or numbers in the canvas box, then click the button 'Classify writing' to classify each character made with one stroke.</h2>

<button id="cut_images_using_boundingboxes" onclick="cut_images_using_boundingboxes()" style="display:block">Classify writing</button>
	
<!-- Once image and model are selected, make image appear in canvas and run model -->
<canvas id="canvasId" width="500" height="500" style="display:block; 'text-align: center"></canvas>


<div id="output" style="font-family:courier;font-size:24px;height:300px"></div>
	    
<style>canvas {border: 1px solid black;}</style>
  
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  
<script>
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage
  var canvasElement = document.getElementById("canvasId");
  const ctx = canvasElement.getContext("2d");

  // -------------------------------------------------
	
  const outp = document.getElementById('output');

  // -------------------------------------------------
  var canvasWidth = 500;
  var canvasHeight = 500;
  var maxX = 0;
  var maxY = 0;
  var minX = canvasWidth;
  var minY = canvasHeight;
  var width = maxX-minX;
  var height = minY-maxY;
  var boundingbox_vec = [];
  var padboundary = 40;
  var spaceBorder = padboundary/2; // the distance from the letter to boundingbox
  var x_start_bottomleft_corner = minX - spaceBorder;
  var y_start_bottomleft_corner = maxY + spaceBorder;

  // -------------------------------------------------
	
  // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientX
  // eventlistener for mousedown
	
  canvasElement.addEventListener("mousedown", (e) => {
     ctx.lineTo(e.offsetX, e.offsetY);
     ctx.lineWidth = 5; //15;  // thickness of line
     ctx.beginPath();
     canvasElement.addEventListener("mousemove", createlines, false);
			 
  }, false);
	


  var createlines = function(e){

     // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageX
     // returns the X (horizontal) coordinate (in pixels) at which the mouse was clicked, relative to the left edge of the entire document (close)
     // ctx.lineTo(e.pageX-e.offsetX, e.pageY-e.offsetY);
     // OR
     // the horizontal/vertical coordinate (offset) of the mouse pointer in screen coordinates. (not correct)
     // ctx.lineTo(e.screenX, e.screenY);
     // OR
     // the horizontal coordinate within the application's viewport at which the event occurred (as opposed to the coordinate within the page). (close)
     // ctx.lineTo(e.clientX, e.clientY);
     // OR
     // provides the offset in the X coordinate of the mouse pointer between that event and the padding edge of the target node. (CORRECT!!)
     ctx.lineTo(e.offsetX, e.offsetY);
	  
     ctx.strokeStyle = "green";  // color of line
     ctx.stroke();

     if (e.offsetX > maxX) {
        maxX = e.offsetX;
     } else {
        maxX = maxX; 
     }
     if (e.offsetY > maxY) {
        maxY = e.offsetY;
     } else {
        maxY = maxY; 
     }
     if (e.offsetX < minX) {
        minX = e.offsetX;
     } else {
        minX = minX; 
     }
     if (e.offsetY < minY) {
        minY = e.offsetY;
     } else {
        minY = minY; 
     }
  };
	
  // -------------------------------------------------
	
  canvasElement.addEventListener("mouseup", () => {

     canvasElement.removeEventListener('mousemove', createlines, false);

     const img = new Image();
     img.onload = () => {
     ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
     };

     // outp.innerHTML = "";
     // outp.innerHTML += "maxX=" + maxX + " : " +  "maxY=" + maxY + " : " +  "minX=" + minX + " : " +  "minY=" + minY + "<br/>";

     // Put each box in a vector: [x_start_bottomleft_corner, y_start_bottomleft_corner, width, height]
     x_start_bottomleft_corner = minX - spaceBorder;
     y_start_bottomleft_corner = maxY + spaceBorder;
	  
     //The rectangle's width. Positive values are to the right, and negative to the left.  
     width = maxX-minX;

     // The rectangle's height. Positive values are down, and negative are up.
     height = minY-maxY; 
     if (width < 0){
        width = width - (2*spaceBorder);
     } else {
        width = width + (2*spaceBorder);
     }

     if (height < 0){
        height = height - (2*spaceBorder);
     } else {
        height = height + (2*spaceBorder);
     }

     // -------------------------
     // Coordinates for image: tensorflow.js cropAndResize
     // boundingbox_vec.push([minY, minX, maxY, maxX]);
     boundingbox_vec.push([minY-spaceBorder, minX-spaceBorder, maxY+spaceBorder, maxX+spaceBorder]);

     // values accumulate in boundingbox_vec
     // outp.innerHTML += "boundingbox_vec entry count:" + "<br/>";
     // for(var i = 0; i<boundingbox_vec.length; i++){
     //    for(var j = 0; j<4; j++){
     //      outp.innerHTML += boundingbox_vec[i][j] + ",";
     //    }	
     //    outp.innerHTML += "<br/>";
     // }
     // -------------------------

     // Coordinates for browser
     ctx.beginPath();
     ctx.lineWidth = '1';
     ctx.strokeStyle = 'red';
     ctx.fillStyle = 'red';
     ctx.rect(x_start_bottomleft_corner, y_start_bottomleft_corner, width, height);
     ctx.stroke();

     maxX = 0;
     maxY = 0;
     minX = canvasWidth;
     minY = canvasHeight;
	  
  }, false);

  // -------------------------------------------------

  async function cut_images_using_boundingboxes() {

	const MODEL_URL = 'model.json';
	const model = await tf.loadLayersModel(MODEL_URL);
	  
	// Obtain image from canvas
	const image = new Image();
	image.src = canvasElement.toDataURL();  // This gives the url to the image drawn on the canvas

	image.onload = async () => {

		var word_out = [];
		
		ctx.drawImage(image, 0, 0, canvasWidth, canvasHeight);

		var tensor_image = tf.browser.fromPixels(image); // This is size 224,224,3
		// outp.innerHTML += 'Max value of entire image: ' + tf.max(tensor_image) + '<br/>';  // Tensor 255

		const image_4D = tensor_image.expandDims(0); // This is size 1,224,224,3

		// const image_4D_float = tf.cast(image_4D, 'float32')
		
		// Make image values from 0 to 1
		// const b = tf.scalar(255);
		// const image_4D_scaled0to1 = image_4D.div(b)
		const shape_out = image_4D.shape;
		
		// Ensure that tensor is 4d
		const x = tf.reshape(image_4D, [1, shape_out[1], shape_out[2], shape_out[3]])

		// -----------------------------------------------
		
		var boxes = tf.tensor2d([[0, 0, 1, 1]], [1, 4]);  // initialize variable
		const boxIndices = tf.tensor1d([0], 'int32');
		const newSize = [28, 28];
		var resizedTensor = tf.image.cropAndResize(x, boxes, boxIndices, newSize);  // resizedTensor.shape= 1,28,28,3

		// outp.innerHTML += 'resizedTensor.shape= ' + resizedTensor.shape + '<br/>';  // resizedTensor.shape= 1,28,28,3

		// -------------------------
		// var resizedTensor_grayscale = resizedTensor.mean(3); // resizedTensor_grayscale.shape= 1,28,28
		var resizedTensor_grayscale = resizedTensor.max(3); // resizedTensor_grayscale.shape= 1,28,28
		// outp.innerHTML += 'resizedTensor_grayscale.shape= ' + resizedTensor_grayscale.shape + '<br/>'; // resizedTensor_grayscale.shape= 1,28,28
		
		var resizedTensor_grayscale_4D = tf.reshape(resizedTensor_grayscale, [1,28,28,1]); // resizedTensor_grayscale_4D.shape= 1,28,28,1
		// outp.innerHTML += 'resizedTensor_grayscale_4D.shape= ' + resizedTensor_grayscale_4D.shape + '<br/>';
		// OR
		// var resizedTensor_rgb_3D = tf.reshape(resizedTensor, [28,28,3]); // resizedTensor_rgb_3D.shape= 28,28,3
		// outp.innerHTML += 'resizedTensor_rgb_3D.shape= ' + resizedTensor_rgb_3D.shape + '<br/>'; 
		// OR
		// Read the red layer only: to understand how to index a tensor in javascript
		// var firstLayer = tf.slice(resizedTensor_rgb_3D, [0, 0, 0], [-1, -1, 0]);
		// var secondLayer = tf.slice(resizedTensor_rgb_3D, [0, 0, 0], [-1, -1, 1]);
		// var thirdLayer = tf.slice(resizedTensor_rgb_3D, [0, 0, 0], [-1, -1, 2]);
		// outp.innerHTML += 'secondLayer.shape test0 = ' + secondLayer.shape + '<br/>'; // secondLayer.shape test0 = 28,28,1
		
		// -------------------------

		const decode_index2numletter = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
		
		// -----------------------------------------------
		
		for (var i = 0; i<boundingbox_vec.length; i++){
			
			// select each bounding box and make a tensor
			// outp.innerHTML += 'boundingbox_vec ' + i + ': ' + boundingbox_vec[i] + '<br/>';

			// -------------------------
			const tensor = tf.tensor(boundingbox_vec[i]);
			const b = tf.scalar(canvasWidth);
			const tensor_from0to1 = tensor.div(b);

			// OR

			//const tensor_from0to1 = tf.tensor([boundingbox_vec[i][0]/canvasHeight, boundingbox_vec[i][0]/canvasWidth, boundingbox_vec[i][0]/canvasHeight, boundingbox_vec[i][0]/canvasWidth]);
			
			// outp.innerHTML += 'tensor_from0to1= ' + tensor_from0to1 + '<br/>';
			// -------------------------
			
			const tensor_from0to1_data = await tensor_from0to1.data();
			boxes = tf.tensor2d([tensor_from0to1_data], [1, 4]);
			
			resizedTensor = tf.image.cropAndResize(x, boxes, boxIndices, newSize);
			
			// -----------------------------------------------
			
			// Convert RGB image [28,28,3] to grayscale [28,28,1]
			// resizedTensor_grayscale = resizedTensor.mean(3);
			resizedTensor_grayscale = resizedTensor.max(3); // This is size 28,28,1
			resizedTensor_grayscale_4D = tf.reshape(resizedTensor_grayscale, [1,28,28,1]);  // OK
			// OR
			// resizedTensor_rgb_3D = tf.reshape(resizedTensor, [28,28,3]);
			// OR
			// Read the red layer only: to understand how to index a tensor in javascript
			// firstLayer = tf.slice(resizedTensor_rgb_3D, [0, 0, 0], [1, -1, -1]);
			// secondLayer = tf.slice(resizedTensor_rgb_3D, [0, 0, 0], [-1, -1, 1]);
			// secondLayer = tf.reshape(secondLayer, [1,28,28,1]);
			// outp.innerHTML += 'secondLayer.shape test1 = ' + secondLayer.shape + '<br/>';
			
			// -----------------------------------------------

			// Create a canvas element
			var canvasElement = document.createElement('canvas');

			// Set the width and height of the canvas
			canvasElement.width = 28;
			canvasElement.height = canvasElement.width;

			// Get the 2D rendering context
			const ctx = canvasElement.getContext("2d");
			
			// Add the canvas to the document body or any other desired element
			document.body.appendChild(canvasElement);

			// ----------------------
	
			// const imageData = new ImageData(new Uint8ClampedArray(resizedTensor_grayscale_4D.dataSync()), 28, 28);
			// DOMException: Index or size is negative or greater than the allowed amount
			
			// OR
			
			// const imageData = await printTensor.data();
			// TypeError: CanvasRenderingContext2D.putImageData: Argument 1 does not implement interface ImageData.

			// OR

			
			// let imageDataArray = new Uint8ClampedArray(28 * 28 * 4);
			// for (let i = 0; i < 28 * 28; i++) {
			     // let value = resizedTensor_grayscale_4D.dataSync()[i];
			//      imageDataArray[i * 4] = value; // Red component
			//      imageDataArray[i * 4 + 1] = value; // Green component
			//      imageDataArray[i * 4 + 2] = value; // Blue component
			//      imageDataArray[i * 4 + 3] = 255; // Alpha component, set to 255 to make it fully opaque
			// }

			// let imageData = new ImageData(imageDataArray, 28, 28);
			// WORKS! but for loop is a bad idea

	// OR

			
			// const r_data = await firstLayer.data();
			// const b_data = await secondLayer.data();
			// const g_data = await thirdLayer.data();
			// ones_vec = tf.ones([1, 28 * 28]).as1D();
			// const b = tf.scalar(255);
			// alpha_component = await ones_vec.mul(b).data();
			//let imageDataArray = new Uint8ClampedArray([r_data][b_data][g_data][alpha_component]);


			// OR
			
			// for loop method
			let imageDataArray = new Uint8ClampedArray(28 * 28 * 4);
			for (let i = 0; i < 28 * 28; i++) {
			     let value = resizedTensor_grayscale_4D.dataSync()[i];
			     imageDataArray[i * 4] = value > 0.5 ? 255 : 0; // Red component
			     imageDataArray[i * 4 + 1] = value > 0.5 ? 255 : 0; // Green component
			     imageDataArray[i * 4 + 2] = value > 0.5 ? 255 : 0; // Blue component
			     imageDataArray[i * 4 + 3] = 255; // Alpha component, set to 255 to make it fully opaque
			}

			let imageData = new ImageData(imageDataArray, 28, 28);

			// OR

			// Tensorflow.js method
			
			// Create a Uint8ClampedArray from the pixels array
			// try 0
			// const pixels = tf.browser.toPixels(resizedTensor_grayscale_4D);  // Assuming you have a tensor named 'tensor' of size 28x28
			// const uint8ClampedArray = new Uint8ClampedArray(pixels);
			// let imageData = new ImageData(uint8ClampedArray, 28, 28);
			// Uncaught (in promise) DOMException: An attempt was made to use an object that is not, or is no longer, usable
			// try 1
			// const pixels = tf.browser.toPixels(resizedTensor_grayscale_4D);
			// let imageData = new ImageData(new Uint8ClampedArray(pixels.dataSync()), 28, 28);
			// Uncaught (in promise) TypeError: pixels.dataSync is not a function
			// try 2
			// const pixels = tf.browser.toPixels(resizedTensor_grayscale_4D);
			// let imageData = new ImageData(new Uint8ClampedArray(pixels), 28, 28);
			// Uncaught (in promise) DOMException: An attempt was made to use an object that is not, or is no longer, usable
			// try 3
			// let imageData = new ImageData(new Uint8ClampedArray(tf.browser.toPixels(resizedTensor_grayscale_4D)), 28, 28);
			// Uncaught (in promise) DOMException: An attempt was made to use an object that is not, or is no longer, usable
			// try 4
			// const pixels = tf.browser.toPixels(resizedTensor_rgb_3D.dataSync());
			// let imageData = new ImageData(new Uint8ClampedArray(pixels), 28, 28);
			
			// ----------------------

			// Draw the image data onto the canvas
			ctx.putImageData(imageData, 0, 0);
			
			// Save the tensor as an image
			// const link = document.createElement('a');
			// link.href = canvasElement.toDataURL("image/png");
			// link.download = `tensor_${i}.png`;
			// link.click();
			
			// -----------------------------------------------
			
			// To confirm, would need to: convert the tensor to Image, then create a canvas, then drawImage to canvas
			// outp.innerHTML += 'resizedTensor_grayscale max= ' + tf.max(resizedTensor_grayscale) + '<br/>'; // resizedTensor_grayscale max= Tensor 85.38902282714844
			
			// outp.innerHTML += 'resizedTensor_grayscale_4D.shape = ' + resizedTensor_grayscale_4D.shape + '<br/>'; //resizedTensor_grayscale_4D.shape = 1,28,28,1
			
			// -----------------------------------------------
			
			// Give image to model
			const result = model.predict(resizedTensor_grayscale_4D); 
			// outp.innerHTML += 'result= ' + result + '<br/>'; // Tensor [[0.0299567, 0.0064958, 0.0322246, ..., 0.0315075, 0.0173011, 0.0218268],]
			// outp.innerHTML += 'result.shape= ' + result.shape + '<br/>'; // correct, 1,36
			// outp.innerHTML += 'Sum value of result: ' + tf.sum(result) + '<br/>'; // correct, sums to 1

			// ----------------------
			// Way 0
			// Get index of maximum softmax probability 
			const index = result.as1D().argMax().dataSync()[0];  // 11
			
			// Get maximum softmax probability 
			const resultData = await result.data(); // correct
			// outp.innerHTML += 'resultData= ' + resultData + '<br/>'; // 0.02995668724179268,0.006495801266282797,...,0.04143814370036125
			const maxprob = resultData[index]; // 0.058055195957422256

			// OR

			// Way 1 : it stopped working ...not sure what is correct
			// const resultData = await result.data(); // correct
			// const {maxprob, index} = tf.topk(resultData); //maxprob=Tensor [0.0580552], index=Tensor [11]
			// OR
			// const {maxprob, index} = tf.topk(result.as1D().dataSync()); // undefined
			// ----------------------

			outp.innerHTML += 'index= ' + index + '<br/>';
			outp.innerHTML += 'maxprob= ' + maxprob + '<br/>';

			// ----------------------

			// Decode the index to the label
			word_out.push(decode_index2numletter[index])
			
			// ----------------------
			
		} // end of for

		outp.innerHTML += 'word_out= ' + word_out + '<br/>';

	}  // end of image.onload
	  
  }
	
  // -------------------------------------------------

</script>
</body>
</html>
